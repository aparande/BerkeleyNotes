\input{../../header.tex}
\begin{document}
\title{EE128 Course Notes}
\author{Anmol Parande}
\date{Fall 2020 - Professor Ronald Fearing}
\maketitle
\textbf{Disclaimer: }These notes reflect 128 when I took the course (Fall 2020). They may not accurately reflect current course content, so use at your own risk.
If you find any typos, errors, etc, please raise an issue on the \href{https://github.com/parandea17/BerkeleyNotes}{GitHub repository}.\\
\tableofcontents
\newpage
\section{Introduction to Control}
The general goal of control is to get some physical system to respond to a reference input in the way we would like.
\begin{definition}
  The plant is the physical system which we would like to control
  \label{defn:plant}
\end{definition}
In general, there are two different types of control.
\begin{definition}
  Open-Loop control is where we pass a reference directly to the actuator to control the plant (see \cref{fig:open-loop}.
  \label{defn:open-loop}
\end{definition}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[auto, node distance=2cm,>=latex']
    % We start by placing the blocks
    \node [input, name=input] (input) {};
    \node [block, name=amp, right of=input, node distance=2cm] (amp) {$K$};
    \node [block, name=actuator, right of=amp, node distance=4cm] (actuator) {Actuator};
    \node [sum, right of=actuator, node distance=2cm] (sum1) {};
    \node [block, name=plant, right of=sum1, node distance=2cm] (plant) {Plant};
    \node [sum, right of=plant, node distance=2cm] (sum2) {};
    \node [output, right of=sum2, node distance=1cm] (output) {};

    \node [input, name=dist1, below of=sum1, node distance=1cm] (disturbance1) {};
    \node [input, name=dist2, below of=sum2, node distance=1cm] (disturbance2) {};

    % Once the nodes are placed, connecting them is easy. 
    \draw [->] (input) -- node {$r(t)$} (amp);
    \draw [->] (amp) -- node {$u(t)$} (actuator);
    \draw [->] (actuator) -- (sum1);
    \draw [->] (sum1) -- (plant);
    \draw [->] (plant) -- (sum2);
    \draw [->] (sum2) -- node[right of=output, node distance=1cm] {output} (output);
    \draw [->] (disturbance1) -- node[below of=disturbance1, node distance=0.5cm] {$d_1(t)$} (sum1);
    \draw [->] (disturbance2) -- node[below of=disturbance2, node distance=0.5cm] {$d_2(t)$} (sum2);
  \end{tikzpicture}
  \caption{Open-Loop Control}
  \label{fig:open-loop}
\end{figure}
Open-Loop control is generally difficult because the disturbances make it difficult to copy the reference exactly.
\begin{definition}
  Closed loop control is using the output of our system and comparing it to the reference in order to generate the control signal (see \cref{fig:closed-loop}).
  \label{defn:closed-loop}
\end{definition}
\begin{figure}[H]
    \centering 
    % The block diagram code is probably more verbose than necessary
    \begin{tikzpicture}[auto, node distance=2cm,>=latex']
        % We start by placing the blocks
        \node [input, name=input] {};
        \node [sum, right of=input] (sum) {};
	\node [block, right of=sum, node distance=2.5cm] (controller) {Controller};
	\node [block, right of=controller, node distance=4cm] (actuator) {Actuator};
	\node [sum, right of=actuator, node distance=2cm] (sum1) {};
        \node [block, right of=sum1, node distance=2cm] (plant) {Plant};
	\node [sum, right of=plant, node distance=2cm] (sum2) {};
    	\node [output, right of=sum2, node distance=1cm] (output) {};

	\node [input, above of=sum1, node distance=0.5cm] (disturbance1) {};
	\node [input, above of=sum2, node distance=0.5cm] (disturbance2) {};
        % We draw an edge between the controller and system block to 
        % calculate the coordinate u. We need it to place the measurement block. 
	\node [block, below of=actuator] (sensor) {Sensor};

        % Once the nodes are placed, connecting them is easy. 
        \draw [draw,->] (input) -- node {$r(t)$} (sum);
	\draw [->] (sum) -- (controller);
	\draw [->] (controller) -- (actuator);
	\draw [->] (actuator) -- (sum1);
	\draw [->] (sum1) -- (plant);
	\draw [->] (plant) -- (sum2);
	\draw [->] (sum2) -- node [name=y] {} (output);
	\draw [->] (sum) -- node {$e(t)$} (controller);
        \draw [->] (y) |- (sensor);
        \draw [->] (sensor) -| node [pos=0.99] {$-$} (sum);

	\draw [->] (disturbance1) -- node[above of=disturbance1, node distance=0.5cm] {$d_1(t)$} (sum1);
	\draw [->] (disturbance2) -- node[above of=disturbance2, node distance=0.5cm] {$d_2(t)$} (sum2);
    \end{tikzpicture}   
    \caption{Closed-Loop Control}
    \label{fig:closed-loop}
\end{figure}
Notice how the output signal is subtracted from a reference signal, and we use the difference (a.k.a the error)
to determine what input we pass into the plant. Looking at the overall transfer function of the system, we see that
\begin{align*}
    Y(s) &= (R(s)-Y(s))H_c(s)H_p(s)\\
    (1+H_c(s)H_p(s))Y(s) &= H_c(s)H_p(s)R(s)\\
    H(s) = \frac{Y(s)}{R(s)} &= \frac{H_c(s)H_p(s)}{1+H_c(s)H_p(s)}
\end{align*}
Depending on what control we use for $H_c(s)$, we can shape this transfer function to be what we want.
\subsection{Types of Control}
\subsubsection{Constant Gain Control}
When $H_c(s) = K_0$, this is known as constant gain control.
$$H(s) = \frac{K_0H_p(s)}{1+K_0H_p(s)}$$
The poles of this system are clearly when $1+K_0H_p(s)=0$.
\subsubsection{Lead Control}
Lead controllers are of the form
$$H_c(s) = K_0\frac{s-\beta}{s-\alpha}$$
Their poles are when
$$1 + K_0\frac{s-\beta}{s-\alpha}H_p(s) = 0$$
\subsubsection{Integral Control}
Integral controller are of the form
$$H_c(s) = \frac{K_0}{s}$$
Their poles are when 
$$1 + \frac{K_0}{s}H_p(s) = 0$$
\subsection{Root Locus Analysis}
For all forms of control, we need to choose a constant which places our poles where we want. Root Locus Analysis
is the technique which helps us determine how our poles will move as $K_0\rightarrow \infty$.
Assuming we only have a single gain to choose, we the poles of the new transfer function will be the roots of
$$1 + K_0H(s)$$ where $H(s)$ is some transfer function that results in the denominator (For example, in constant gain control, $H(s) = H_p(s)$ but for
lead control, $H_s = \frac{s-\beta}{s-\alpha}H_p(s)$).
\begin{definition}
    The root locus is the set of all points $s_0\in \mathbb{C}$ such that $\exists K_0>0$ such that $1+K_0H(s)=0$.
\end{definition}
This definition implies that $H(s_0)=\frac{1}{K_0}$ for some $K_0$, meaning the root locus is all points such that $\angle H(s_0)=-180$\textdegree.
The first step of RLA is to factor the numerator and denominator of $H(s)$
$$H(s) = \frac{\prod_{i=0}^{m}{(s-\beta_i)}}{\prod_{i=0}^{n}{(s-\alpha_i)}}$$
As $k\rightarrow 0, H(s_0)=-\frac{1}{K_0}\rightarrow \infty$, so the root locus begins at the poles.
As $k\rightarrow \infty, H(s_0)=-\frac{1}{K_0}\rightarrow 0$, so the root locus will end at the open loop zeros.
However, if $m < n$, (i.e there are more poles than 0's), not all of the poles can converge to a zero.
Instead $n-m$ branches will approach $\infty$ witth asymptotes at
$$\frac{\sum_i^n\alpha_i-\sum_i^m\beta_i}{n-m}$$ and angles of
$$\frac{180 + (i-1)*360}{n-m}$$
The final rule of RLA is that parts of the real line left of an odd number of real poles and zeros are on the root locus.
RLA tells us that we have to be careful when choosing our gain $K_0$ because we could by mistake cause instability. In particular, high gain will cause instability if
\begin{itemize}
    \item $H(s)$ has zeros in the right half of the plane
    \item if $n-m \ge 3$, then the asympototes will cross the imaginary axis.
\end{itemize}
\subsection{Feedback Controller Design}
When we design systems to use in feedback control, there are certain properties we want besides just basic ones like stability.
Because signals can be thought of as a series of step signals, when analyzing these properties,
we will assume $r(t)=u(t)$ 
\subsubsection{Steady State Tracking Accuracy}
\begin{figure}[H]
    \centering
    
    % The block diagram code is probably more verbose than necessary
    \begin{tikzpicture}[auto, node distance=2cm,>=latex']
        % We start by placing the blocks
        \node [input, name=input] {};
        \node [sum, right of=input] (sum) {};
        \node [block, right of=sum] (controller) {$H_c(s)$};
        \node [block, right of=controller, node distance=3cm] (system) {$H_p(s)$};
        % We draw an edge between the controller and system block to 
        % calculate the coordinate u. We need it to place the measurement block. 
        \draw [->] (controller) -- node[name=x] {$x(t)$} (system);
        \node [output, right of=system] (output) {};
        \node [below of=x] (measurements) {};

        % Once the nodes are placed, connecting them is easy. 
        \draw [draw,->] (input) -- node {$u(t)$} (sum);
        \draw [->] (sum) -- node {$e$} (controller);
        \draw [->] (system) -- node [name=y] {$y(t)$}(output);
        \draw [-] (y) |- (measurements);
        \draw [->] (measurements) -- ++ (2,0) -| node [pos=0.99] {$-$} (sum);
    \end{tikzpicture}   
\end{figure}
\begin{definition}
    A system has steady state tracking accurracy if the different between the reference and the output signals
    tends to 0 as $t\rightarrow \infty$
    $$e_{ss} := \lim_{t\rightarrow\infty}{e(t)}=0$$
\end{definition}
A useful theorem which can help us evaluate this limit is the final value theorem.
\begin{theorem}[Final Value Theorem]
    $$\lim_{t\rightarrow\infty}{e(t)} = \lim_{s\rightarrow0}{sE(s)}$$
    As long as a limit exists and $e(t)=0$ for $t<0$
\end{theorem}
Looking at the relationship between $E(s)$ and $R(s)$, we see that 
$$\frac{E(s)}{R(s)} = \frac{1}{1+H_c(s)H_p(s)} \implies E(s) = \frac{\frac{1}{s}}{1+H_c(s)H_p(s)}$$
Thus
$$e_{ss}=\lim_{s\rightarrow0}{\frac{1}{1+H_c(s)H_p(s)}}$$
Thus as long as $H_c(s)H_p(s)$ has at least one pole at $s=0$, then $e_{ss}=0$.
Notice that integral control gives us a pole at $s_0$, so it is guaranteed that an integral controller will be steady-state accurate.
\subsubsection{Disturbance Rejection}
\begin{figure}[H]
    \centering
    
    % The block diagram code is probably more verbose than necessary
    \begin{tikzpicture}[auto, node distance=2cm,>=latex']
        % We start by placing the blocks
        \node [input, name=input] {};
        \node [sum, right of=input] (sum) {};
        \node [block, right of=sum] (controller) {$H_c(s)$};
        \node [sum, right of=controller, node distance=2cm, pin={[pinstyle]above:d}] (disturbance) {+};
        \node [block, right of=disturbance, node distance=2cm] (system) {$H_p(s)$};
        % We draw an edge between the controller and system block to 
        % calculate the coordinate u. We need it to place the measurement block. 
        \node [output, right of=system] (output) {};
        \node [below of=x] (measurements) {};

        % Once the nodes are placed, connecting them is easy. 
        \draw [draw,->] (input) -- node {$u(t)$} (sum);
        \draw [->] (sum) -- node {$e$} (controller);
        \draw [->] (controller) -- (disturbance);
        \draw [->] (disturbance) -- (system);
        \draw [->] (system) -- node [name=y] {$y(t)$}(output);
        \draw [-] (y) |- (measurements);
        \draw [->] (measurements) -- ++ (2,0) -| node [pos=0.99] {$-$} (sum);
    \end{tikzpicture}   
\end{figure}
Sometimes the output of our controller can be disturbed before it goes into the plant. Ideally, our system
should be robust to these disturbances.
\begin{align*}
    Y(s) &= H_p(s)\left[H_c(s)(R_s-Y_s)+D(s)\right]\\
    Y(s) &= \frac{H_c(s)H_p(s)}{1+H_c(s)H_p(s)}R(s) + \frac{H_p(s)}{1+H_c(s)H_p(s)}D(s)
\end{align*}
The system will reject disturbances if the $\frac{H_p(s)}{1+H_c(s)H_p(s)}D(s)$ is close to $0$ in the steady state.
Assuming that $d(t) = u(t)$, we see that
$$\delta_{ss} = \lim_{s\rightarrow0}{s\frac{H_p(s)}{1+H_c(s)H_p(s)}\frac{1}{s}}=\lim_{s\rightarrow0}{\frac{H_p(s)}{1+H_c(s)H_p(s)}}$$
Thus as long as $H_c$ has a pole at $0$, then the system will reject disturbances. Notice that integral control guarantees disturbance rejection
as well.
\subsubsection{Noise Insensitivity}
\begin{figure}[H]
    \centering
    
    % The block diagram code is probably more verbose than necessary
    \begin{tikzpicture}[auto, node distance=2cm,>=latex']
        % We start by placing the blocks
        \node [input, name=input] {};
        \node [sum, right of=input] (sum) {};
        \node [block, right of=sum] (controller) {$H_c(s)$};
        \node [sum, right of=controller, node distance=2cm, pin={[pinstyle]above:d}] (disturbance) {+};
        \node [block, right of=disturbance, node distance=2cm] (system) {$H_p(s)$};
        % We draw an edge between the controller and system block to 
        % calculate the coordinate u. We need it to place the measurement block. 
        \node [output, right of=system] (output) {};
        \draw [->] (system) -- node [name=y] {$y(t)$}(output);
        \node [sum, below of=y, pin={[pinstyle]right:n}] (noise) {};
        \node [below of=x] (measurements) {};

        % Once the nodes are placed, connecting them is easy. 
        \draw [draw,->] (input) -- node {$u(t)$} (sum);
        \draw [->] (sum) -- node {$e$} (controller);
        \draw [->] (controller) -- (disturbance);
        \draw [->] (disturbance) -- (system);
        
        \draw [->] (y) -- (noise);
        \draw [-] (noise) |- (measurements);
        \draw [->] (measurements) -- ++ (2,0) -| node [pos=0.99] {$-$} (sum);
    \end{tikzpicture}   
\end{figure}
In real systems, our measurement of the output $y(t)$ is not always 100\% accurate. One way to model this is to add a noise term to the output.
Looking at the relationship between the noise and the output signal, we see
$$H(s) = \frac{-H_c(s)H_p(s)}{1+H_c(s)H_p(s)}$$
In order to reject this noise, we want this term to be close to 0, so ideally $H_c(s)H_p(s) << 1$ as $s\rightarrow 0$.
However, this conflicts with our desire for $H_c(s)H_p(s)$ to have a pole at 0 to guarantee steady state tracking. Thus it is difficult to make a controler
that is both accurate and robust to noise. However, because noise is usually a high frequency signal and the reference is a low frequency signal, we can mitigate
this by choosing $H_c(s)H_p(s)$ to be a low-pass filter.
\end{document}
